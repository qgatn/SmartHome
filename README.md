# SmartHome
This is a Smart Home project using Arduino Mega 2560. In this porject there are 2 Arduino, namely, Master (Arduino 1) and Child (Arduino 2). 

Arduino 1 (Code: https://github.com/qgatn/SmartHome/blob/1d503fcc48116578ecc47eb5e1d5530486d1bbb4/1.2.ino) – (Arduino Mega 2560)
Our design work can be divided into 4 main subroutines. The first is our Bluetooth subroutine, this is where Master Arduino keeps scanning continuously for input from the user. This part of the system can be considered as the brain of the system because every input from the user gets processed here (This can be found in the ‘BT_read()’ function in the 1.2.ino). Every input from the user has a unique starting code, for example, if the user is sending humidity level from the app, the app automatically adds a ‘!’ symbol at the first position to notify the Arduino that the value is for Smart Irrigation Humidity level. Likewise, there are different symbols that are used to specify what inputs are sent. 
‘+’ and ‘-‘ are used to denote that alarm timing is being added or removed respectively.
‘/’ and ‘\‘ are used to denote that Schedule is being added or removed respectively.
‘:’ and ‘;‘ are used to denote that Pet Food dispenser timing is being added or removed respectively.

Once the ‘BT_read()’ function identifies what input is received, it calls other functions as required. For Alarms, it either adds or removes alarm from the alarm array as required or if the alarm is for room 2, i.e. r = 2, then we see that ‘wifi_up()’ is invoked. If the alarm is for room 1 (i.e. the current room), then the ‘EP_up()’ is called which basically updates the E-paper to show the list of alarms that have been set to that particular room. The ‘EP_up()’ function uses a set of mathematical formulas to create list dots and for line spacing to make the E-paper look eligant. If there is a Schedule input, then the system first checks which user is editing their Schedule, this is done by using the second position of the input string which is ‘1’ for user 1 and ‘2’ for user 2. This is important as we have divided a String array of length 100 into 0-49 for User 1 and 50-99 for User 2. We use the variables ‘pt1’ and ‘pt2’ to save how many inputs are there for both users. For Pet Food dispenser Timing, ‘wifi_up()’ is directly invoked. The ‘wifi_up()’ is the function that uploads the required input to the ThingSpeak channel. The arguments in ‘wifi_up()’ are (int hc, int mc, int s, int f) where ‘hc’ and ‘mc’ are the hour and minute inputs respectively. ‘s’ denotes the status that has to be set in the Field 2 of the channel and ‘f’ is the field in which the value of (hc*100)+mc has to uploaded to. The status in Field 2 is very important and will be discussed later. 

The next subroutine is the ‘oled_up()’ routine which keeps the OLED up to date and also helps with the time control. ‘oled_up()’ takes one argument (int a) which controls what the OLED has to display. For example, when a = 1, it will only show the ‘Welcome,’ message, for a = 2, it will show the show string ‘receiving Bluetooth data….’ below the ‘Welcome,’ string. Few values such as a = 100, a = 30 and a = 50 are used to display the bitmaps that add great visual effects to the Smart Home. The most important part of the ‘oled_up()’ function is a = 4 condition. This condition gets the current time from the RTC and checks if it is displaying the correct time. If the time from the RTC module is different from the time that is being displayed in the OLED, it moves to change the OLED display. When the OLED display is being changed, we also check if there are any alarms set for the current time. If there is an alarm for the current time, then we turn the variable ‘alarm_flag’ to 1. This helps with the efficiency as there is only one check a min for alarms and only one check per minute is required to check for alarms. When an alarm is rung, ‘next_alarm()’ is invoked which finds when the next closest alarm is. Finding the next closest alarm prevents us from having to loop through the entire alarm array to see if there are any alarms at a particular time. 

The third subroutine is the alarm subroutine. This subroutine starts when the alarm_flag = 1. The check condition for alarm_flag == 1 takes place in the loop function. When the condition is satisfied, we see that ‘oled_up(30)’ is called which displays an alarm clock in the OLED. Then ‘final’ and ‘time_left’ are set to 0, they are used to play the alarm song. Then the ‘sing()’ function is called. This function is using the predefined ‘melody[]’ and ‘tempo[]’ array to play the Mario Theme on the buzzer. To activate the buzzer to buzz the required ‘frequency’ for ‘length’ time, the ‘buzz()’ function is used. It is to be noted that in the ‘sing()’ function, before every note that is played, ‘RF()’  is called which basically scans for any RFID tap. If there are any RFID that is being tapped, the RFID UID is checked with existing UIDs, if there is a match then ‘flag’ and ‘me’ is changed to 1 or 2 depending on the RFID. Once the ‘RF()’ is completed, the control is returned back to ‘sing()’ , but this time, the ‘me’ not equal to 0, and ‘oled_up(32)’ is started. ‘oled_up(32)’ is used to display the schedule depending on which user tapped their RFID. 

The last subroutine is the Smart Irrigation subroutine. This implementation is slightly different from the other routines. We use a manual delay ‘mandelay’, this is to make sure that we do not waste processing time by checking the moisture content every time the ‘loop()’ function is looped. We cannot use the inbuilt ‘delay()’ function as it would halt all other processes as well. So when every time we go through ‘loop()’, we decrement ‘mandelay’ by 1. One drawback of this implementation is that the delay is not always at the same time because if some other subroutine is called, then the delay would take longer as we will have to manually decrease ‘mandelay’ value. But there is no need to be time accurate in Smart irrigation as we will definitely chk once atleast evey 5 – 10s (worst case senario). Every time ‘mandelay’ is less than 1, we check the soil moisture content using the senor connected to pin A0. We then see if the current moisture level is lesser than the required level, if it is lesser than required level, then we call the ‘iteration()’. ‘iteration()’ is a simple function that gives a short impulse to the DC water pump which pushes a small quantity of water to the plant. We send small quantities as we need to give time for the water to be absorbed by the soil, else the water will overflow from the plant pot. There is no need to worry about the plant running dry because even the smallest drop of moisture level (as small as 1/100th) will trigger the pump and the soil will be watered. 

Arduino 2 – (Arduino Mega 2560)
The Arduino 2 uses many similar functions as the Arduino 1, but the loop function is changed to actively scan the ThingSpeak channel for any input from Arduino. This is where the ‘s’ from the ‘wifi_up()’ function comes into play. You will see that every upload has a different ‘s’ value. For example, to add an alarm s = 1, to remove an alarm s = -1, to add pet food time = 5 and to remove pet food time s = -5. To scan every field in ThingSpeak channel would be very inefficient thus, Arduino 2 will only scan for field 2. If there is any other value in field 2 other than 0, then ‘wifi_down()’ is called.
 
‘wifi_down()’ function uses the value stored in variable ‘c’ to know which exact field to read from. If c = +1 or -1, then the field to be read from is 1 and if c = +5 or -5, then the field is 3. After the reading is completed, any required modification is done, i.e., adding or removing values from arrays. To avoid the Arduino 2 from repeating the read from ThingSpeak channel again, we upload value ‘0’ to Field 2 of the channel. This implementation keeps the reading from the channel simple and efficient. 

The ‘oled_up()’ is very similar to the Arduino 1, with the only difference being, a Wi-Fi download symbol will be shown when ‘wifi_down()’ is being called. The ‘iteration()’ function in Arduino 2 is used to control the Servo motor for Pet Food Dispenser. When the current time is equal to time set for Pet food, then we see that ‘iteration()’ function is invoked. This function makes the servo motor open to 90 degrees and close. This opening and closing is done ‘numoftrns’ times which is pre-set in the program. After the bowl has been filled by the servo motor, a buzzer sound is made to alert the pet that Food has been served, the buzzer is controlled by ‘buzz()’ function.

The ‘loop()’ function keeps reading Field 2 of the channel for any status, if the read is 0 then it means that all values have already been read. If the read value is not equal to 0, then ‘wifi_down()’ function is called to carry out any necessary task. 
